# ECE444-F2023-Lab5

## Advantages and Disadvantages of Test Driven Development (TDD)

Some of the advantages of Test Driven Development (TDD) include allowing programmers to detect issues and bugs in the code early in the development process. By writing the tests first based on the feature requests/specifications, programmers can develop based on the code’s passability of tests, allowing bugs to be resolved early. Furthermore, using TDD allows for higher quality, easily maintainable and modular code. Since developers are constructing code specifically to pass the tests, it results in well-organized, easy-to-understand code. This also helps the communication in a team environment, making it easier for teammates to understand each other’s code. Other benefits include allowing developers to automate their testing processes, which is more efficient than manual testing procedures. Furthermore, it provides programmers with a higher degree of confidence when deploying code, as they know their code passes corresponding tests. Additionally, by incorporating the testing process throughout the code development process, the testing procedure is not rushed, allowing for a better quality of code. Moreover, this form of testing is highly compatible with Agile methodology, which often works in sprints for large teams. So, it allows specific tests to be completed per sprint, and iterative improvements in later sprints. 

On the other hand, having to write the tests for the TDD process can be time-consuming and results in a lot of initial overhead. If a fast pace of release/code deployment is necessary, the TDD methodology can be difficult to integrate as the process involves extensive testing throughout code development. As well, although there are multiple types of tests in the TDD process (unit testing, integration testing, end-to-end testing), there is still a possibility that developers do not cover all test cases. This lapse in coverage can lead to further bugs in the long-term development of the code. It is also important to note that this methodology does not work well for every type of coding project. For projects where the requirements and features are constantly evolving and there is no clear final design, it can be difficult to create tests prior to beginning to code.
